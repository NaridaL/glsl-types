import moo from "moo"
export function makeLexer() {
  const lexer = moo.compile({
    VERSION: {
      match: /[ \t\v\f\r\n]*#[ \t\v\f\r\n]*version[ \t\v\f\r\n]+\d+[ \t\v\f\r\n]+es[ \t\v\f]*(?:\r\n|\n\r|\r|\n)/,
      lineBreaks: true,
    },
    PRE_DEFINE: "#define",
    PRE_IFDEF: "#ifdef",
    PRE_ENDIF: "#endif",
    PRE_IFNDEF: "#ifndef",
    PRE_ELSE: "#else",
    PRE_ELIF: "#elif",
    PRE_IF: "#if",
    PRE_UNDEF: "#undef",
    PRE_LINE: "__LINE__",
    PRE_FILE: "__FILE__",
    PRE_VERSION: "__VERSION__",
    PRE_GL_ES: "GL_ES",
    WS: /[ \t]+/,
    NL: { match: ["\r\n", "\n\r", "\r", "\n"], lineBreaks: true },
    COMMENT_LINE: { match: /\/\/[^\n\r]*/ },
    COMMENT_MULTILINE: { match: /\/\*[^]*?\*\//, lineBreaks: true },
    IDENTIFIER: {
      match: /[_a-zA-Z][_a-zA-Z0-9]*/,
      keywords: {
        CONST: "const",
        UNIFORM: "uniform",
        VARYING: "varying",
        ATTRIBUTE: "attribute",
        LAYOUT: "layout",
        CENTROID: "centroid",
        FLAT: "flat",
        SMOOTH: "smooth",
        BREAK: "break",
        CONTINUE: "continue",
        DO: "do",
        FOR: "for",
        WHILE: "while",
        SWITCH: "switch",
        CASE: "case",
        DEFAULT: "default",
        IF: "if",
        ELSE: "else",
        IN: "in",
        OUT: "out",
        INOUT: "inout",
        BOOLCONSTANT: ["true", "false"],
        INVARIANT: "invariant",
        DISCARD: "discard",
        RETURN: "return",
        TYPE: [
          "float",
          "int",
          "bool",
          "mat2",
          "mat2",
          "mat3",
          "mat4",
          "mat2x2",
          "mat2x3",
          "mat2x4",
          "mat3x2",
          "mat3x3",
          "mat3x4",
          "mat4x2",
          "mat4x3",
          "mat4x4",
          "vec2",
          "vec3",
          "vec4",
          "ivec2",
          "ivec3",
          "ivec4",
          "bvec2",
          "bvec3",
          "bvec4",
          "uint",
          "uvec2",
          "uvec3",
          "uvec4",
          "sampler2D",
          "sampler3D",
          "samplerCube",
          "sampler2DShadow",
          "samplerCubeShadow",
          "sampler2DArray",
          "sampler2DArrayShadow",
          "isampler2D",
          "isampler3D",
          "isamplerCube",
          "isampler2DArray",
          "usampler2D",
          "usampler3D",
          "usamplerCube",
          "usampler2DArray",
        ],
        // FLOAT:                'float',
        // INT:                  'int',
        VOID: "void",
        // BOOL:                 'bool',
        // MAT2:                 'mat2',
        // MAT3:                 'mat3',
        // MAT4:                 'mat4',
        // MAT2X2:               'mat2x2',
        // MAT2X3:               'mat2x3',
        // MAT2X4:               'mat2x4',
        // MAT3X2:               'mat3x2',
        // MAT3X3:               'mat3x3',
        // MAT3X4:               'mat3x4',
        // MAT4X2:               'mat4x2',
        // MAT4X3:               'mat4x3',
        // MAT4X4:               'mat4x4',
        // VEC2:                 'vec2',
        // VEC3:                 'vec3',
        // VEC4:                 'vec4',
        // IVEC2:                'ivec2',
        // IVEC3:                'ivec3',
        // IVEC4:                'ivec4',
        // BVEC2:                'bvec2',
        // BVEC3:                'bvec3',
        // BVEC4:                'bvec4',
        // UINT:                 'uint',
        // UVEC2:                'uvec2',
        // UVEC3:                'uvec3',
        // UVEC4:                'uvec4',
        // SAMPLER2D:            'sampler2D',
        // SAMPLER3D:            'sampler3D',
        // SAMPLERCUBE:          'samplerCube',
        // SAMPLER2DSHADOW:      'sampler2DShadow',
        // SAMPLERCUBESHADOW:    'samplerCubeShadow',
        // SAMPLER2DARRAY:       'sampler2DArray',
        // SAMPLER2DARRAYSHADOW: 'sampler2DArrayShadow',
        // ISAMPLER2D:           'isampler2D',
        // ISAMPLER3D:           'isampler3D',
        // ISAMPLERCUBE:         'isamplerCube',
        // ISAMPLER2DARRAY:      'isampler2DArray',
        // USAMPLER2D:           'usampler2D',
        // USAMPLER3D:           'usampler3D',
        // USAMPLERCUBE:         'usamplerCube',
        // USAMPLER2DARRAY:      'usampler2DArray',
        LOW_PRECISION: "lowp",
        MEDIUM_PRECISION: "mediump",
        HIGH_PRECISION: "highp",
        PRECISION: "precision",
        STRUCT: "struct",
      },
    },
    FLOATCONSTANT: /(?:(?:[0-9]+\.[0-9]*|\.[0-9]+)(?:[eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+)[fF]?/,
    INTCONSTANT: /0[0-7]+[uU]?|0[xX][0-9a-fA-F]+|[1-9][0-9]*|0/,
    UINTCONSTANT: /0[0-7]+[uU]?|0[xX][0-9a-fA-F]+|[1-9][0-9]*/,

    LEFT_OP: "<<",
    RIGHT_OP: ">>",
    INC_OP: "++",
    DEC_OP: "--",
    LE_OP: "<=",
    GE_OP: ">=",
    EQ_OP: "==",
    NE_OP: "!=",
    AND_OP: "&&",
    OR_OP: "||",
    XOR_OP: "^^",
    MUL_ASSIGN: "*=",
    DIV_ASSIGN: "/=",
    ADD_ASSIGN: "+=",
    MOD_ASSIGN: "%=",
    LEFT_ASSIGN: "<<=",
    RIGHT_ASSIGN: ">>=",
    AND_ASSIGN: "&=",
    XOR_ASSIGN: "^=",
    OR_ASSIGN: "|=",
    SUB_ASSIGN: "-=",
    LEFT_PAREN: "(",
    RIGHT_PAREN: ")",
    LEFT_BRACKET: "[",
    RIGHT_BRACKET: "]",
    LEFT_BRACE: "{",
    RIGHT_BRACE: "}",
    DOT: ".",
    COMMA: ",",
    COLON: ":",
    EQUAL: "=",
    SEMICOLON: ";",
    BANG: "!",
    DASH: "-",
    TILDE: "~",
    PLUS: "+",
    STAR: "*",
    SLASH: "/",
    PERCENT: "% ",
    LEFT_ANGLE: "<",
    RIGHT_ANGLE: ">",
    VERTICAL_BAR: "|",
    CARET: "^",
    AMPERSAND: "&",
    QUESTION: "?",
  })
  const oldNext = lexer.next
  lexer.next = function () {
    let token
    do {
      token = oldNext.call(this)
    } while (
      token &&
      ("WS" == token.type ||
        "COMMENT_LINE" == token.type ||
        "COMMENT_MULTILINE" == token.type)
    )
    return token
  }
  return lexer
}
